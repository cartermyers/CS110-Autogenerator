Autogenerated Questions Paper Notes
(format pending)

Problem Description
--------------------
- online tests for large classes (N ~ 200)
- cheating is a Problem
- We want to give unique questions that have the same difficulty
- with Moodle (or any other online classroom), we can import questions given the markup language
- Also describe basic GIFT format and stuff?
- we can write a program to generate a virtually infinite amount of questions
- Moodle handles some parts (select question randomly from a bank for each student; randomize the order of answers)
- Level of randomness
    - not too random, but a structured question (like avoid bad randomness, and have controlled randomness - such as picking an increment from 1, 5, or 10)
    - have some randomness that doesn't really affect question but may "throw off" students (like different identifiers)
    - good to prevent trivial cases (like x - x)

Flow
--------------------
- Given the executable, there are a few inputs:
    a) A template control file that contains all information (around 7 inputs) EXPLAIN ALL INPUTS
    This way it's easy to make incremental changes and run the program multiple times.
    b) All command-line inputs. This can be cumbersome with the 7 inputs, but this allows us to
    c) Write a small script to generate all types of questions in one command.

- Maybe also explain some are subcategories and some are difficulty? Maybe just call it difficulty?
- All questions are output to a single file (specified in the inputs). In the case of (c), each category has its respective file (ending in "examples")
- With the inputs, this allows for some variability, such as excluding certain difficulties or subcategories.
- When imported to Moodle, because of the GIFT formatting, each subcategory (difficulty) appears as its own question bank, which allows us to give students the exact number for that difficulty.


Common Functions
--------------------
- Common program treats all questions the same (i.e. same format of prompt, right question, variable number of wrong questions)
- Convincing distractors need to be used (examples here), but then we must also guarantee that each answer is unique (and especially that no wrong answer is the same as the right answer.
    If it is not unique, we can sacrifice the convincing distractor for a unique one (that is close to the right answer). This is fairly simple in cases of integer answers, however,
    some answers involving a vector of arrays (see Arrays category). Since most answers are based on positioning, we can just shuffle the answer if it is not unique. However, we
    then need to guarantee all of the permutations are unique (to ensure we don't go in an infinite loop). ETC.


Testing (?)
--------------------
- Of course, it's important to make sure our generation actually creates the right answer, that's why we test the functions as best as possible.
    Wrong MC questions (in this context, where no correct answer -- or the correct answer is labelled as a wrong answer -- causes more work for the
    instructor than just making the question probably would).


AT END:
Fututre Improvements/What's next


********************
EACH CATEGORY
********************


GROUPS:

Intro:
    1) Identifiers
    2) Conditional Expressions
    3) Expressions

Loops:
    1) Different types of loops (for, while, do-while)
    2) Loops counting vs. Loops printing

More advanced:
    1) Switch Cases (kind of on its own)
    2) Arrays (uses loops)
    3) Functions (uses Expressions)



Template for each difficulty:
a) Here is the goal of the question (and how they differ between other difficulties)
b) Here is an example
c) Here are the random parts (what is important, what isn't, and how it serves the question purpose)
 - The importance needs to be mentioned by a different name. Maybe i) essential parts of a question (that is
 divided into ones that are randomized and ones that are not. For example) and ii) non-deterministic (or non-essential?) parts of a question?
 Basically, essential parts add to difficulty and are used to solve the question; non-deterministic parts are randomized
 (so they add to the individiualization or whatever) but they don't affect the essence of the question.
 Also, for the essential randomized parts, it may be important to note the domain of generated values.
 There are also some things that are determined by the random elements (e.g. the number of iterations a loop takes; "a - a" in an expression)
 and these can be modified to fit inside some defined parameters (i.e. we can modify the loop members to guarantee it runs a certain amount of times)
d) Here are the (interesting) distractor methods

Arrays
==================

Difficulty 1
--------------------
a) This question aims to test if students can correctly identify explicit access and assignment in an array.
b) What are the contents of the array after the following statements?
int bar[6] = {6, 5, 3, 8, 1, 9};
int temp;
temp = bar[4];
bar[4] = bar[1];
bar[1] = temp;
c) What's important (Domain):
	The size of the array (4 : 6)
	The contents   (unique integers 0 : 10)
	The first and second indices (0 : (size of array) - 1)
  What's not:
	The identifier of the array
d) Interesting distractor methods:
   Distractor 1: The original array
   Distractor 2: Off-by-one error (correct indices are added by one modulus size of array)
   Distractor 3: Off-by-one error (correct indices are subtracted by one)
   Distractor 4: Off-by-one errors in both directions (first index is subtracted by 1, the other is added by one)


Difficulty 2
--------------------
a) This question aims to test if students can correctly see how updates (and loops) affect array access
b) What are the contents of the array after the following?
int documents[6] = {3, 3, 10, 1, 1, 2};
for (int i = 0; i < 6; i += 1)
	{ documents[i] += 5; }
c) Important randomization:
    Size of array (3 : 6)
    Element update offset (between 1, 5, and 10)
    Array contents (integers 0 : 10)
   What's not:
    Array identifier
d) Interesting distractor methods:
    Distractor 1: The original array
    Distractor 2: Off-by-one error for update value (e.g. updates by 6 instead of 5)
    Distractor 3: Loop variable (as if it was assigned to the array value)
    Distractor 4: Subtracts the offset instead of adding


Difficulty 3
--------------------
a) This question aims to test if students can correctly identify spots in an array from a loop (and recognize out of bounds index errors).
b) What is printed after the following statements?
int dogs[6] = {0, 1, 7, 3, 0, 2};
for (int i = 1; i < 4; i = i + 1)
{
	cout << dogs[i] << " ";
}
c)
Essential but not random:
    Loop increment operator (always +=)
What's important:
    Size of array (3 : 6)
    Array contents (integers 0 : 10)
    Beginning value for i (0 : floor(size(array)) / 2)
    Loop comparison operator (either < or <=)
    Loop comparison operand (size(array) +/- 1)
    Loop increment operator (1 : 2)

    NOTE: each loop is guaranteed to iterate between 2 and 4 times
Not important:
    Array identifier
d) Interesting distractor methods:
    Distractor 1: Off-by-one error (correct indices are added by one loop increment modulus size of array)
    Distractor 2: Off-by-one error (correct indices are subtracted by one loop increment modulus size of array)
    Distractor 3: Simply the previous value in the array (off-by-one error)
    Distractor 4: "Run-time error due to out of bound index." - this has the option of being a correct answer, and
        then the previously generated correct answer would be used as a distractor


Loops Preamble

NOTE: should we also mention the "infinite loop" thing? It can be a part of the implementation, not necessary however.
But it does add some interesting stuff, like we can have non-homogeneous answer types (string and int), and
also methods to detect infinite loops and then change the answer accordingly.

Loop Counting
==================

Difficulty 1
--------------------
a) Test how many times the loop runs to test basic knowledge on loops
b) How many times does the '*' print?
for (int b = 4; b < 7; b = b + 1)
{
	cout << '*';
}
c)
Essential but not random:
    Comparison operator (always <)
    Increment Operator (always +=)
What's Important:
    Starting value (2 : 10 and then scaled based on increment)
    Ending value (start + increment * (3 : 6) + (0 : increment - 1))
    Increment (by 1, 5, or 10)
Not important:
    Identifier
d) Distractor 1: abs(Right answer - 1)
Distractor 2: Right answer + 1
Distractor 3 and 4: A random value that is the answer +/- (2 : 4)


Difficulty 2
--------------------
a) Same structure and aim as difficulty 1, but it introduces more comparison operators
and a subtraction operator for increment.
b)
How many times does the '*' print?
int j = 53;
do
{
	cout << '*';
	j = j - 5;
} while (j >= 30);
c)
Essential but not random:

Essential (Domain):
    Starting value (same domain as Difficulty 1)
    Ending value
    Comparison operator (any of <, <=, >, >=)
    Increment operator (either += or -=)
    Increment (by 1, 5, or 10)
Non-essential:
    Identifier
d) All same as difficulty 1.


Difficulty 3
--------------------
a) Same structure and aim as difficulty 2, but it uses *= and /= instead of += and -=
b)
How many times does the '*' print?
int i = 13;
while (i >= 3)
{
	cout << '*';
	i /= 2;
}
c)
Essential but not random:

Essential (Domain):
    Starting value (1 : 4)
    Ending value (Starting value * pow(increment, 3) + (0 : increment - 1)) or more precisely, the midpoint of the desired amount of loops
    Comparison operator (any of <, <=, >, >=)
    Increment operator (either *= or /=)
    Increment (by 2 or 10)
Non-essential:
    Identifier
d) Same as difficulty 1.


Difficulty 4
--------------------
a) The same structure as difficulty 2, except as a nested loop.
b)
How many times does the '*' print?
for (int i = 43; i >= 20; i = i - 10)
{
	for (int j = 56; j > 45; j = j - 5)
	{
		cout << '*';
	}
}
c) All same randomization methods as difficulty 2, but the identifiers are not randomized in
this case (to easily guarantee that they are unique).
d)
Distractor 1: The outer loop count + 1
Distractor 2: The outer loop count
Distractor 3: (The outer loop count + 1) * (The inner loop count)
Distractor 4: (The outer loop count + 1) * (The inner loop count + 1)

Loop Printing
==================

Difficulty 1
--------------------
a) This question shows a loop that prints out the loop variable at each iteration.
The purpose of this question is to show if students know the exact control structure
and context at each iteration.
b)
int g = 6;
while (g < 10)
{
	cout << g << ' ';
	g += 1;
}
c)
Essential but not random:
    Comparison operator (<)
    Increment operator (+=)
Essential (Domain):
    Starting value (2 : 10 then scaled based on increment)
    Ending value (start + increment * (2 : 3) + (0 : increment - 1))
    Increment (by 1, 5, or 10)
Non-essential:
    Identifier
d)
Example answer: 6 7 8 9

Distractor 1: The same values as the correct answer, omitting the first value (7 8 9)
Distractor 2: The same values as the correct answer, appending one more iteration (6 7 8 9 10)
Distractor 3: The same values as the correct answer, omitting the last value (6 7 8)
Distractor 4: Combining distractor 1 and 2  (7 8 9 10)

Difficulty 2
--------------------
a) Same as difficulty 1 but it introduces the -= operator
b)
int b = 61;
do
{
	cout << b << ' ';
	b = b - 10;
} while (b > 20);
c)
Essential but not random:

Essential (Domain):
    Starting value (same domain as Difficulty 1)
    Ending value
    Comparison operator (any of <, <=, >, >=)
    Increment operator (either += or -=)
    Increment (by 1, 5, or 10)
Non-essential:
    Identifier
d) Same as difficulty 1.

Difficulty 3
--------------------
a) Same as difficulty 2 but with *= and /=
b)
for (int c = 21; c > 4; c = c / 2)
{
	cout << c << ' ';
}
c)
Essential but not random:

Essential (Domain):
    Starting value (1 : 4)
    Ending value (Starting value * pow(increment, 3) + (0 : increment - 1)) or more precisely, the midpoint of the desired amount of loops
    Comparison operator (any of <, <=, >, >=)
    Increment operator (either *= or /=)
    Increment (by 2 or 10)
Non-essential:
    Identifier
d) Same as difficulty 1.

Expressions
==================

Difficulty 1-4
--------------------
NOTE: All 4 difficulties use the same methods,
the only differing factor is the number of operands in the expression.

a) This is a simple question that is used at the beginning of the course
to test students on integer operations, variable access, and some operator precedence.
b)
What is the variable "bar" equal to?
int foo = 2;
int bar = foo * 4 % 2 + 4;
c)
Essential but not random:

Essential (Domain):
    Number of operands (decided by difficulty)
    Value of operands (2 : 10)
    Types of operators (any of +, -, *, /, or %)
Non-essential:
    The two identifiers are random, but unique.
d)
Distractor 1: The expression evaluated with no order of operations
Distractor 2: The expression evaluated with no order of operations and treated as float operands
Distractor 3: The expression evaluated from right to left
Distractor 4: The expression is evaluated with operands treated as floats

Functions
==================

Difficulty 3 (NOTE: change to 3 because it's probably the hardest)
--------------------
a) The objective of this question is to test how the values of variables are affected
based on reference parameters.
b)
Given the following function definition:
void Calculate(int& a, int& b, int c)
{
	b = a / b + c;
}

What value is printed after the following statements?
int marks = 5;
int matrix = 4;
int item = 5;
Calculate(marks, matrix, item);
cout << matrix << endl;

c)
Essential but not random:
    The number of parameters (this can be randomized, but it is simpler to
        keep it constant)
    Number of variables (this can be randomized, but it is simpler to keep
        constant)
    It should be noted that there of course must be (Number of variables) >= (Number of parameters)
    Datatypes (all are type int)
    The variable printed at the end of the question always corresponds to
        the parameter assigned in the function (e.g. matrix is printed in the
        example because it was passed in the spot of parameter b)
Essential (Domain):
    All parameters have 50/50 chance of being reference or pass-by-value
    The expression is randomized (see expression questions for methods)
    The parameter assigned in the function (the "reference" parameter)
Non-essential:
    All identifiers (variables and function)
    Order that the variables are passed (using the example, the call could be
        Calculate(marks, matrix, item) or Calculate(item, marks, matrix)).
        This option can be selected or deselected in the code.
    Order that the parameters appear in the expression (again, using the example,
        it could be (a / b + c) or (c / b + a)).
        This option also can be selected or deselected in the code.
    Both of the previous two options can make the question more complicated
        for students without changing the essence, so they are most often not used.
        But it is good to note for future applications that this can add to a
        significant amount of randomness.
d)
Distractor 1: If the parameter is reference, then this is the original value of the variable. If not, it is the value of the function expression.
Distractor 2: The value of the functional expression with no order of operations
Distractor 3: The value of the variable that comes after the printed variable (e.g. item in the case above)
Distractor 4: The value of the functional expression using float operations

Difficulty 2
--------------------
a) This question tests type coercion as well as operations based on datatypes of parameters
b)
Given the following function definition:

float Switch(float a, int b)
{
    return a - b;
}
What is printed from the following call?
cout << Switch(3.5, 1.5) << endl;
c)
Essential but not random:
    Function return type (always float to provide the most general answer)
    Number of parameters (same reason as difficulty 1)
Essential (Domain):
    Datatypes of the parameters (either float or int, but always different)
    Values of parameters that are passed (2 : 10 and a possibilty of ending in 0.5);
        they are never the same)
    Operation (never % because it is not supported by float)
Non-essential:
    Order that the parameters appear in the expression (see previous difficulty; also optional)
    All identifiers
d)
Distractor 1: The expression with no order of operations
Distractor 2: The expression using the original float values
Distractor 3: The expression using the original float values and with no order of operations
Distractor 4: The floor of the correct answer (to provide an integer-like answer)

Difficulty 1
--------------------
a) Another question to test type coercion, but with function return types.
Because the return type has an option of being void, the correct answer is
sometimes a "Run-time Error", due to the print statement.
b)
Given the following function definition:
int Pow()
{
	return 4.5 + 1.0;
}

What is printed from the following call?
cout << Pow() << endl;
c)
Essential but not random:
    Number of operands (can be randomized)
Essential (Domain):
    Value of operands (1 : 10; possibility of ending in 0.5)
    Operation (never % because its not supported by float)
    Function return type (one of int, float, or void)
Non-essential:
    Identifier
d)
Distractor 1: Expression from right to left (and float value)
Distractor 2: Integer value if float return type; float value if integer return type
Distractor 3: Always "Run-time Error"
Distractor 4: If the return type is not void, it is "Compile-time error". If it is, it is the float value of the expression




Switch Cases
==================

All switch cases are the same (same objective; use the same distractors),
but they vary in their randomness of some elements (only part c is different).

a) Test students' knowledge of the control structure of switch cases (including some break statements)
b)
What is the value of "bar" after the switch/case block?
int bar = 4;
switch (bar) {
	case 2:
		bar = 5;
		break;
	case 4:
		bar = 6;
		break;
	case 1:
		bar = 4;
	case 3:
		bar = 0;
	case 0:
		bar = 1;
		break;
}
c) See each difficulty
d)
There are two cases for distractors 1 and 2.
If there is a corresponding case to the initial value:

Distractor 1: This is the value of the first case statement (this is a good distractor
    when there is not a break statement).
Distractor 2: This is the value of the case with the next break (i.e. the next case, following
    the matching case, with a break statement)

If there is no corresponding case:
    (Here again, there are two cases)
    If there is a default case:
        Distractor 1: This is the last assignment value before the default value
        Distractor 2: This is the last case value before the default

    If there is no default case:
        Distractor 1: Just a random assignment value from the block
        Distractor 2: The first case value


Distractor 3: The original value
Distractor 4: The last assignment value in the block (which may be the default case)


Difficulty 1
--------------------
c)
Essential but not random:
    Of course, the variable is always int
Essential (Domain):
    Number of cases (3 : 5)
    All values - the initial value, the case values, and the assigned values (1 : (1 : Number of cases * 3 / 2))
        NOTE: all assigned values are guaranteed to be unique and different from the initial value
    There is a 50/50 chance for each case to have a break statement
    There is also a 50/50 chance for a default case to be in the switch case
Non-essential:
    Identifier

Difficulty 2
--------------------
c) All same as difficulty 1, except that it guarantees that all cases have a break statement, and there
is always a default statement.

Difficulty 3
--------------------
c) All same as difficulty 1, except that there are no break statements, but there is always a default statement.

Difficulty 4
--------------------
c) The same as difficulty 1, except there are no break statements, and there is no default statement.



Identifiers
==================

NOTE: There currently is no real difference between difficulties.

Difficulty 1 - 4
--------------------
a) A very basic question introduced at the beginning of the course. It aims to see if students know valid identifiers in c++
b)
Is the following a valid C++ identifier?
Tb306wN
c)
Essential but not random:

Essential (Domain):
    The whole string is random (but it is only made of alphanumeric characters for the most part)
        The first character has a 1 / 5 chance of being a number (and therefore invalid).
        There is always a 1 in 10 chance for each character that it is a invalid character
    The length of the string (5 : 9)
Non-essential:
d) There are no distractors for this question as it's true/false.


Conditionals
==================

Difficulty 1 and 2
--------------------
a) This tests basic logic operators for students. This also tests some operator precedence
    (as == and != has higher precedence than &&, which has higher precedence than ||)
b)
What is the result of the following logical expression?

int numbers = 3;
int marks = 8;
(numbers >= 4) == (marks >= 10)
c)
Essential but not random:
    Number of "sub-expressions" (that is, the expressions seen in parentheses).
        This is always equal to the number of declared variables.
        This is always 2 for difficulty 1 and 3 for difficulty 2.
    Variables are always of type int.
    The order of operands appear in the same order that they are declared in. variables
        always come before literals.
Essential (Domain):
    Value of variables and operands (1 : 10)
    The operators - all "sup-expressions" are only made up of 2 operands and one of (>, >=, <, <=)
        The operators in-between the sub-expressions are one of (==, !=, ||, &&)
Non-essential:
    Identifiers
d) None because it is true/false.

Difficulty 3 and 4
--------------------
a) Same aim and structure as 1 and 2. The only difference is that the order of the operands are randomized
b)
int documents = 8;
int bar = 10;
(bar <= documents) != (10 < 9)
