Autogenerated Questions Paper Draft


Problem Description (needs work)
--------------------
For any large introductory undergraduate course, testing becomes virtually impossible on a (clerical?) level, especially for a small examination
such as an in-class quiz. However, technology allows instructors to develop and distribute exams in an online environment,
easing the arduous task of passing out and collecting paper exams. However, extra problems are presented with online tests (especially those
without a proctor), such as authentication, blah, and most importantly cheating (reference). Some solutions have been discussed before (reference),
but problems still remain. In an effort to prevent cheating, instructors may use different questions for different students, but the task of creating exam
questions (let alone multiple ones) has been noted to be very intensive and time-consuming (reference). A possible solution to this problem has been
presented by (reference)

Input/output Flow
--------------------

Given the executable file and a templated file for input, it becomes extremely easy to generate any number of questions
repeatedly. In most cases, we wish to generate a single category of questions at a time, and this is the basis for the
overall structure of the main program. It simply checks the user's input from the predefined file to read basic inputs
such as the Main Category and Subcategory names (for identification in Moodle), the filename for output, the number of
total questions to generate, the question set -- or category -- to generate from (such as Arrays, Functions, etc.),
the base difficulty, and the max difficulty of questions. By having this input file, it becomes easy to slightly modify
any parameters and repeatedly run the program.

However, this method becomes tedious if one wishes to generate questions from every category. For this reason, the
executable program also excepts 7 command-line arguments (that, in any other case, are cumbersome and virtually
unusable) which allows a small shell script to easily generate questions from every category in one command.

Once the program has finished, all output files generated in .txt format containing the GIFT-formatted questions, and they can be uploaded
directly to the Moodle course with no extra effort. Each category is contained in its own file, and any
difficulties selected within the category are automatically separated into their own question banks, allowing
for exam questions to be selected by difficulty.


Common Functions
--------------------

Each question, regardless of category, follows the same format: the title (including unique question number),
a prompt to explain the question, the right answer, and a number of wrong answers (that can vary between categories).
A standard question in GIFT looks something like this:

::Dynamic Expressions Level 1 #005::
Solve the following problem:
<pre>int item = 4;
int bar = item / 3 - 3;</pre>
What is the variable "bar" equal to?
	{
	=-2
	~-0.5
	~-1.667
	~1.5
	~0
	}

NOTE: why am I describing how GIFT or Moodle works? This seems unnecessary and boring.

The title at the beginning (enclosed by two colons on each side) contains the subcategory name, "level" (i.e. difficulty) and a unique number (simply the current number
of questions generated in this batch). This information is necessary in Moodle to differentiate between 1) different question banks (e.g. "Dynamic Expressions Level 1") and
2) different questions within the question bank (e.g. #005 vs. #006). For this reason, it is reccomnded that only one output file per category be used to avoid any confusion
in the naming of question banks on Moodle.

The answer bank at the end (enclosed by the braces) contains all answer options for the question. The correct answer is preceded by the "=" and all wrong answers are denoted by
the "~". When either of these identifiers is used, a answer is taken to be any text until a line break.

Anything between the title and the answer bank is
considered to be the prompt, or the actual question being asked. GIFT format also allows HTML tags to be inserted,
so usually <pre> tags are used to separate code excerpts and for readability.

Since we follow this basic structure for each question, we can abstract the implementation so each category
only needs to generate a prompt and the corresponding answers. For this reason, the act of creating a new
category of questions takes much less time to implement, and question-writers can be focused on the content of
the question, rather than its final format. This also allows questions to have some certain specialized attributes
(e.g. a different type of answer options, a true/false question, etc.), but most attributes are fixed or required (such as each question
must have a title, a prompt, etc.).

Subsection: Difficulty
=========================

The most important of these fixed attributes are the static number of difficulties offered. Each question category is
limited by four possible difficulties, however it is not necessary that all four difficulties are implemented by each category
as long as it is made explicit to the user. Although this fixed number of difficulties appears to be a shortfall of this
implementation (and it is a focus for improvement in the future), these difficulties offer a great deal of flexibilty
within a category of a question.

The most simple case of difficulty is found in the Expressions category (see Expressions below)
that simply serves to test a student's understanding of integer operations and variable assignment in programming.
Each difficulty is the same essential type of question, but the number of operands increases with increasing difficulty.
Some may consider this a naive approach to difficulty, but it is effective and showcases the fundamental relation
between question categories and difficulties.

Other question categories (such as Switch Cases) don't exhibit such a straightforward
notion of difficulty, but still an interesting example. Still, each difficulty is essentially the same where students are tested on their
ability to follow the control flow of a switch case statement by determining the final value of a variable (see Switch Cases for more detail).
The first difficulty randomly generates break statements (for each case) and it may or may not include a default case, where the second difficulty
always includes a break statement for each case and automatically includes a default case. Each difficulty of the Switch Case category follows the
same pattern by simply modifying random elements of the same core quesiton. While one may seem like more common -- but not necessarily always
correct -- example of a switch case block, it seems difficult to argue that one is inherently more "difficult" than another. However, it is clear
that each difficulty of this category would be beneficial to test in its own right, while still being able to test students fairly.

In contrast to these categories that implement the same essential question with slight changes, some categories (such as Functions
or Arrays), hold completely different questions in each difficulty. Here, a descriptor like "subcategory" seems more appropriate
(since it becomes harder to evaluate question on difficulty in relation to a different question), but
to avoid confusion, we will continue to reference these subcategories as difficulties. At first, it also seems like these questions shouldn't
be included in the same category, as each may be warranted their own category. However, because each relates to the same category
(by testing the same fundamental concept) and any less or extra randomization in the question would not provide anything beneficial to
the question, but rather would shift focus from the objective of the question. We won't discuss in detail how a level of randomness affects,
a question, but there is a certain amount of randomness in a question that no longer serves the purpose of making a question unique,
but instead it makes a question unnecesarily difficult to comprehend. In short, these different difficulties are not substantial enough to
create their own category and are similar enough to each other to be included in the same category.

Although it now may seem that this concept of difficulty is unclear and unfocused, it is important to note that each of these in Moodle are
formed as their own question bank (meaning students are each given questions from the same bank -- meaning the same difficulty -- and not only
the same category -- with different difficulties. The instructor then has the option of using whichever question bank (i.e. difficulty) is most appropriate,
and it offers a fair test to each student. Overall, it gives the instructor more choice on how to exactly test his or her students.

=========================
End of Difficulty Subsection

Subsection: Unique Answer Guarantee
================================

Because of the universal format for questions, extra error checks can be done. While there is no general way
to ensure that each question provides the correct answer (see Testing), we can confirm that each answer is unique
(and especially that no distractor is the same as the right answer) -- a seemingly trivial, but essential, restraint.
This can become complicated is for two reasons: i) in an effort to create more convincing distractors,
each difficulty in each category generates its own distractors using "clever" methods (e.g. evaluating an expression
without order of operations, or evaluating an expression based on wrong datatypes) and ii) complex answers
(in particular, answers containing vectors; see Arrays) become more difficult to compare and even more difficult
to generate an arbitrary new distractor (for the sake of uniqueness) that is still a somewhat plausible answer.
In the case of (i), it is fairly simple to compare all answers, and any distractors that are not unique are reassigned
a random value close to the answer. This is usually done with computational questions where the answer is simply a
numerical value. However, in the case of (ii), if we were to simply alter a value in the vector, the distractor would
become completely implausible because the answer only contains values that are originally in the array (see Arrays
Difficulty 1). It would make no sense at all to change a value in the array. In order to generate distractors that
are still plausible (but are guaranteed to be unique), we can simply shuffle the order of the vector. Yet, this has
another precondition that the number of permutations for the correct answer must be greater than or equal to the
number of available answers. Without this restraint, there would not be enough unique answers. If this is not met,
then it suffices to revert to the original strategy and simply assign a random value to the vector. Although it may
not be very convincing, unique distractors take precedence over plausible ones.


Testing
--------------------


********************
EACH CATEGORY
********************


Arrays
==================

Difficulty 1
--------------------
This question aims to test if students can correctly identify explicit spots in an array.
Here is an example.
Here are the random parts.
Here are the distractor methods

Difficulty 2
--------------------
This question aims to test if students can correctly see how updates (and loops) affect array access
Here are the distractor methods

Difficulty 3
--------------------
This question aims to test if students can correctly identify spots in an array from a loop (and recognize out of bounds index errors).
Here are the distractor methods


Loops Preamble

Loop Counting
==================

Difficulty 1
--------------------


Difficulty 2
--------------------


Difficulty 3
--------------------


Difficulty 4
--------------------


Loop Printing
==================

Difficulty 1
--------------------


Difficulty 2
--------------------


Difficulty 3
--------------------


Expressions
==================

Difficulty 1
--------------------


Difficulty 2
--------------------


Difficulty 3
--------------------


Difficulty 4
--------------------



Functions
==================

Difficulty 1
--------------------


Difficulty 2
--------------------


Difficulty 3
--------------------





Switch Cases
==================

Difficulty 1
--------------------


Difficulty 2
--------------------


Difficulty 3
--------------------


Difficulty 4
--------------------




Identifiers
==================

Difficulty 1
--------------------


Difficulty 2
--------------------


Difficulty 3
--------------------


Difficulty 4
--------------------



Conditionals
==================

Difficulty 1
--------------------


Difficulty 2
--------------------


Difficulty 3
--------------------


Difficulty 4
--------------------
