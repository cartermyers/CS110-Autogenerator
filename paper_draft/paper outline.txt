Autogenerated Questions Paper Notes
(format pending)

Problem Description
--------------------
- online tests for large classes (N ~ 200)
- cheating is a Problem
- We want to give unique questions that have the same difficulty
- with Moodle (or any other online classroom), we can import questions given the markup language
- Also describe basic GIFT format and stuff?
- we can write a program to generate a virtually infinite amount of questions
- Moodle handles some parts (select question randomly from a bank for each student; randomize the order of answers)
- Level of randomness
    - not too random, but a structured question (like avoid bad randomness, and have controlled randomness - such as picking an increment from 1, 5, or 10)
    - have some randomness that doesn't really affect question but may "throw off" students (like different identifiers)
    - good to prevent trivial cases (like x - x)

Flow
--------------------
- Given the executable, there are a few inputs:
    a) A template control file that contains all information (around 7 inputs) EXPLAIN ALL INPUTS
    This way it's easy to make incremental changes and run the program multiple times.
    b) All command-line inputs. This can be cumbersome with the 7 inputs, but this allows us to
    c) Write a small script to generate all types of questions in one command.

- Maybe also explain some are subcategories and some are difficulty? Maybe just call it difficulty?
- All questions are output to a single file (specified in the inputs). In the case of (c), each category has its respective file (ending in "examples")
- With the inputs, this allows for some variability, such as excluding certain difficulties or subcategories.
- When imported to Moodle, because of the GIFT formatting, each subcategory (difficulty) appears as its own question bank, which allows us to give students the exact number for that difficulty.


Common Functions
--------------------
- Common program treats all questions the same (i.e. same format of prompt, right question, variable number of wrong questions)
- Convincing distractors need to be used (examples here), but then we must also guarantee that each answer is unique (and especially that no wrong answer is the same as the right answer.
    If it is not unique, we can sacrifice the convincing distractor for a unique one (that is close to the right answer). This is fairly simple in cases of integer answers, however,
    some answers involving a vector of arrays (see Arrays category). Since most answers are based on positioning, we can just shuffle the answer if it is not unique. However, we
    then need to guarantee all of the permutations are unique (to ensure we don't go in an infinite loop). ETC.


Testing (?)
--------------------
- Of course, it's important to make sure our generation actually creates the right answer, that's why we test the functions as best as possible.
    Wrong MC questions (in this context, where no correct answer -- or the correct answer is labelled as a wrong answer -- causes more work for the
    instructor than just making the question probably would).


AT END:
Fututre Improvements/What's next


********************
EACH CATEGORY
********************

Template for each difficulty:
a) Here is the goal of the question (and how they differ between other difficulties)
b) Here is an example
c) Here are the random parts (what is important, what isn't, and how it serves the question purpose)
d) Here are the (interesting) distractor methods

Arrays
==================

Difficulty 1
--------------------
a) This question aims to test if students can correctly identify explicit access and assignment in an array.
b) What are the contents of the array after the following statements?
int bar[6] = {6, 5, 3, 8, 1, 9};
int temp;
temp = bar[4];
bar[4] = bar[1];
bar[1] = temp;
c) What's important:
	The size of the array
	The contents
	The first and second indices
  What's not:
	The identifier of the array
d) Interesting distractor methods:
   Distractor 1: The original array
   Distractor 2: Off-by-one error (correct indices are added by one modulus size of array)
   Distractor 3: Off-by-one error (correct indices are subtracted by one)
   Distractor 4: Off-by-one errors in both directions (first index is subtracted by 1, the other is added by one)


Difficulty 2
--------------------
a) This question aims to test if students can correctly see how updates (and loops) affect array access
b) What are the contents of the array after the following?
int documents[6] = {3, 3, 10, 1, 1, 2};
for (int i = 0; i < 6; i += 1)
	{ documents[i] += 5; }
c) Important randomization:
    Size of array
    Element update offset (between 1, 5, and 10)
    Array contents
   What's not:
    Array identifier
d) Interesting distractor methods:
    Distractor 1: The original array
    Distractor 2: Off-by-one error for update value (e.g. updates by 6 instead of 5)
    Distractor 3: Loop variable (as if it was assigned to the array value)
    Distractor 4: Subtracts the offset instead of adding


Difficulty 3
--------------------
a) This question aims to test if students can correctly identify spots in an array from a loop (and recognize out of bounds index errors).
b) What is printed after the following statements?
int dogs[6] = {0, 1, 7, 3, 0, 2};
for (int i = 1; i < 4; i = i + 1)
{
	cout << dogs[i] << " ";
}
c) What's important:
    Size of array
    Array contents
    Beginning value for i
    Loop condition (either < or <= and a random ending value)
    Loop update (usually a small value between 1 and 3)
Not important:
    Array identifier
d) Interesting distractor methods:
    Distractor 1: Off-by-one error (correct indices are added by one loop increment modulus size of array)
    Distractor 2: Off-by-one error (correct indices are subtracted by one loop increment modulus size of array)
    Distractor 3: Simply the previous value in the array (off-by-one error)
    Distractor 4: "Run-time error due to out of bound index." - this has the option of being a correct answer, and
        then the previously generated correct answer would be used as a distractor


Loops Preamble

Loop Counting
==================

Difficulty 1
--------------------
a) Test how many times the loop runs to test basic knowledge on loops
b) How many times does the '*' print?
for (int b = 4; b < 7; b = b + 1)
{
	cout << '*';
}
c) What's Important:
    Starting value
    Ending value
    Increment (by 1, 5, or 10)
Not important:
    Identifier
d) Distractor 1: Right answer - 1
Distractor 2: Right answer + 1


Difficulty 2
--------------------


Difficulty 3
--------------------


Difficulty 4
--------------------


Loop Printing
==================

Difficulty 1
--------------------


Difficulty 2
--------------------


Difficulty 3
--------------------


Expressions
==================

Difficulty 1
--------------------


Difficulty 2
--------------------


Difficulty 3
--------------------


Difficulty 4
--------------------



Functions
==================

Difficulty 1
--------------------


Difficulty 2
--------------------


Difficulty 3
--------------------





Switch Cases
==================

Difficulty 1
--------------------


Difficulty 2
--------------------


Difficulty 3
--------------------


Difficulty 4
--------------------




Identifiers
==================

Difficulty 1
--------------------


Difficulty 2
--------------------


Difficulty 3
--------------------


Difficulty 4
--------------------



Conditionals
==================

Difficulty 1
--------------------


Difficulty 2
--------------------


Difficulty 3
--------------------


Difficulty 4
--------------------
